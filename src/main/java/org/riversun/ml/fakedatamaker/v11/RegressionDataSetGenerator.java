package org.riversun.ml.fakedatamaker.v11;

import java.io.File;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.riversun.file_grabber.TextFileWriter;
import org.riversun.ml.fakedatamaker.v11.AttributeNumeric.AttributeNumericValue;

public class RegressionDataSetGenerator {

	private List<Attribute> attrs;

	public List<Attribute> getAttrs() {
		return attrs;
	}

	public void setAttrs(List<Attribute> attrs) {
		this.attrs = attrs;
	}

	public DataRuleCompliantListener getCompliantListener() {
		return compliantListener;
	}

	public void setCompliantListener(DataRuleCompliantListener compliantListener) {
		this.compliantListener = compliantListener;
	}

	public String generateCsvRandomValues(double baseValue) {
		return generateCsvRandomValues(baseValue, 0.0);
	}

	private String toCsvLabels(String resultLabel) {
		StringBuilder sb = new StringBuilder();

		for (Attribute attr : attrs) {
			sb.append(attr.label);
			sb.append(",");
		}
		sb.append(resultLabel);

		return sb.toString();
	}

	private DataRuleCompliantListener compliantListener = new DataRuleCompliantListener() {

		@Override
		public boolean isCompliant(AttributeCheck valueMap) {
			return true;
		}
	};

	public String generateCSV(int numOfLines) {
		return generateCSV(numOfLines, "target", 1.0);
	}

	/**
	 * 
	 * @param numOfLines
	 *            Number of lines to generate as a dummy data set
	 * @param targetLabel
	 *            Target to predict
	 * @param targetInitialValue
	 *            The initial value that will be used for multiplication when
	 *            calculating the target.
	 * @return
	 */
	public String generateCSV(int numOfLines, String targetLabel, double targetInitialValue) {
		return generateCSV(numOfLines, targetLabel, targetInitialValue, 0.0, true, true);
	}

	/**
	 * 
	 * @param numOfLines
	 *            Number of lines to generate as a dummy data set
	 * @param targetLabel
	 *            Target to predict
	 * @param targetInitialValue
	 *            The initial value that will be used for multiplication when
	 *            calculating the target.
	 * @param valueVolatility
	 *            A random value to be added to the computed value. computed by
	 *            "volatility * Math.random () * targetInitialValue"
	 * @param withHeader
	 *            true:generate csv with header row.
	 * 
	 * @param withId
	 *            true:generate autogenerated sequential id column
	 * @return
	 */
	public String generateCSV(int numOfLines, String targetLabel, double targetInitialValue, double valueVolatility,
			boolean withHeader, boolean withId) {

		StringBuilder sb = new StringBuilder();
		if (withHeader) {
			if (withId) {
				sb.append("id,");
			}
			sb.append(toCsvLabels(targetLabel));
			sb.append("\n");
		}

		for (int i = 0; i < numOfLines; i++) {
			if (withId) {
				sb.append(i).append(",");
			}
			sb.append(generateCsvRandomValues(targetInitialValue, valueVolatility));
			sb.append("\n");
		}
		return sb.toString();

	}

	public void setDataRuleCompliantListener(DataRuleCompliantListener listener) {
		compliantListener = listener;
	}

	public String generateCsvRandomValues(double baseValue, double volatility) {

		Map<String, AttributeValue> attributeValues = new LinkedHashMap<>();
		final StringBuilder sb = new StringBuilder();

		double computedValue = 0;

		do {
			computedValue = baseValue + (volatility * Math.random() * baseValue);
			sb.setLength(0);
			for (Attribute attr : attrs) {
				if (attr.isNominal) {
					AttributeNominal randomNominal = attr.generateRandomNominal();
					sb.append(randomNominal.name);
					sb.append(",");
					computedValue *= randomNominal.coefficient;

					attributeValues.put(attr.label, randomNominal);
				} else {
					AttributeNumericValue randomNumeric = attr.generateRandomNumeric();
					sb.append((int) randomNumeric.numericValue);
					sb.append(",");
					computedValue *= randomNumeric.coefficient;
					attributeValues.put(attr.label, randomNumeric);
				}

			}
		} while (!compliantListener.isCompliant(new AttributeCheck(attributeValues)));

		sb.append((int) computedValue);
		return sb.toString();
	}

	public void saveAsUTF8(File file, String string) {
		save(file, "UTF-8", string);
	}

	public void save(File file, String encoding, String string) {

		TextFileWriter w = new TextFileWriter();
		w.writeText(file, string, encoding, false);
	}

	public void saveAsUTF8WithBom(File file, String encoding, String string) {

		TextFileWriter w = new TextFileWriter();
		w.writeTextAsUTF8WithBOM(file, string, false);
	}
}